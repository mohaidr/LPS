Top priority
https://www.linkedin.com/feed/update/urn:li:activity:7313644642816716801?utm_source=share&utm_medium=member_desktop&rcm=ACoAAE-ts5YBpZtgyWjgiIP5AwlxSHLA5P7OctU

🐞 Potential Bugs
1. The status for the multiple clients is broken 
    - I cant reproduce
2. Currently the metrics are not updated on the local nodes
    - Done with fragile logic
3. Test the metrics on distributed environment thoroughly
4. Review Logging for all the new services related to the GRPC Implementation

🚀 Enhancements

10. Add Automatic Termination Rules

11. Server Metrics

12. Reporting and Analysis

13. Comparisons with other tools

14. Methods
  14.1. SetIf
  14.2. Jumb (like 5 and then 15) – done


5. Think of the registration process in the Discovery entity
  5.1. Should we add the iterations of the local node to the discovery record?
    - I created an entity repository service to achieve that without touching the discovery process

6. Unify the client creation process to use the new factory
  - Done, created a gRPC client factory

7. Should we add predicate overload to every queryable service?

8. Should the discovery on the local node call the discovery on the primary?
  - If yes, what is the benefit and the use cases?

9. Documentation for the services and the GRPC implementation


======== Urgent List ========

correctly calculate the time taken to start and complete a request
Provide Statistics
use fluent validation for the domain

add header validation to http 2 requests and possibly refactor the http client service
Put all test plans in one folder
use prompt plus

create, update, delete commands
Json Repository
Iqueryable repository to be passed for the domain
move the infra logic to the infra layer
Integrated Metric pipeline
When creating a repository, create IEntityPolicy so the repository applies then before an entity is saved or updated => for example, immutable field like an Id
document how to use dot net trace

======== To Do List ========
//ToDo: Implement CleanUp Cookies
Gather the logs of each request and its associated response in one log file // this requires a logger manager to create a logger each time a case is executed

Review the desgin relationships
Cookie manager to support custom cookies and support enabling disabling cookies per domain. For now cookies are enabled by defaults for all clients and all domains
redirects - Http Redirections for now is enabled for all domains and all clients

cache manager
shared settings across all requests 
Remove Completed Tasks

command to run multiple plans??


private async Task RemoveCompletedTasks(List<Task> tasks, CancellationToken token)
{
    int sizeInBytes = int.MaxValue;
    while (!token.IsCancellationRequested)
    {
        if (sizeInBytes > 10485760)
        {
            await _logger.LogAsync("1111111111", "Removing completed tasks, list is greater than 10 MB", LoggingLevel.WRN);

            sizeInBytes = tasks.Count * Marshal.SizeOf(typeof(Task));
            var completedTasks = tasks.Where(t => t.IsCompleted || t.IsCanceled || t.IsFaulted).ToList();
            foreach (var task in completedTasks)
            {
                tasks.Remove(task);
            }
        }
        await Task.Delay(20000);
    }
}

Expose Performence Counters

Implement Low and Slow Attacks
    Syn flood attack
    Slowlories attack
    Socket Stress Attack
    R.U.D.Y Attack

======== Done List ========
console logger option - Done
provide an option to not run the test plan after creating it manually - Done
logging per client - done
Logging Correlation Ids - done
Number of clients behavior  - Should I make my queue to track the number of requests per host per all clients? or change the way I deal with clients - Done
Logging Behavior - Done
Exit app after command execution is completed - Done
Implement RunInParallel
Handle Response Payload As Bytes and read it as soon as it arrives
download embedded resources
Resource Usage Tracker
Command to configure file logging options
Command to configure watchdog
Command to configure httpclient
support for http2


