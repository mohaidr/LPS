Top priority
https://www.linkedin.com/feed/update/urn:li:activity:7313644642816716801?utm_source=share&utm_medium=member_desktop&rcm=ACoAAE-ts5YBpZtgyWjgiIP5AwlxSHLA5P7OctU

1- Complete the distributed Version
    1.1- Think of the registration process in the Discovery entity (should we add the iterations of the local node to the discovery record?)
        - I created an entity repository service to acheive that without touching the discovery process
    1.2- Unify the client creation process to use the new factory
    1.3- Should we add predicate overload to every queryable service?
    1.4- Test the metrics on distributed environment thoroughly
    1.5- Currently the metrics are not updated on the local nodes
    1.6- Review Logging for all the new services related to the GRPC Implementation
    1.7- **Should the discovery on the local call the discovery on the primary? if yes, what is the benefit and the use cases?**
    1.8- Documentation for the services and the GRPC implementation
2- Add Automatic Termination Rules
3- The status for the multiple clients is broken
4- Server Metrics
5- Reporting and Analysis
6- Comparisons with other tools.
7- Methods
    - SetIf
    - Jumb (like 5 and then 15 and )
======== Urgent List ========

correctly calculate the time taken to start and complete a request
Provide Statistics
use fluent validation for the domain

add header validation to http 2 requests and possibly refactor the http client service
Put all test plans in one folder
use prompt plus

create, update, delete commands
Json Repository
Iqueryable repository to be passed for the domain
move the infra logic to the infra layer
Integrated Metric pipeline
When creating a repository, create IEntityPolicy so the repository applies then before an entity is saved or updated => for example, immutable field like an Id
document how to use dot net trace

======== To Do List ========
//ToDo: Implement CleanUp Cookies
Gather the logs of each request and its associated response in one log file // this requires a logger manager to create a logger each time a case is executed

Review the desgin relationships
Cookie manager to support custom cookies and support enabling disabling cookies per domain. For now cookies are enabled by defaults for all clients and all domains
redirects - Http Redirections for now is enabled for all domains and all clients

cache manager
shared settings across all requests 
Remove Completed Tasks

command to run multiple plans??


private async Task RemoveCompletedTasks(List<Task> tasks, CancellationToken token)
{
    int sizeInBytes = int.MaxValue;
    while (!token.IsCancellationRequested)
    {
        if (sizeInBytes > 10485760)
        {
            await _logger.LogAsync("1111111111", "Removing completed tasks, list is greater than 10 MB", LoggingLevel.WRN);

            sizeInBytes = tasks.Count * Marshal.SizeOf(typeof(Task));
            var completedTasks = tasks.Where(t => t.IsCompleted || t.IsCanceled || t.IsFaulted).ToList();
            foreach (var task in completedTasks)
            {
                tasks.Remove(task);
            }
        }
        await Task.Delay(20000);
    }
}

Expose Performence Counters

Implement Low and Slow Attacks
    Syn flood attack
    Slowlories attack
    Socket Stress Attack
    R.U.D.Y Attack

======== Done List ========
console logger option - Done
provide an option to not run the test plan after creating it manually - Done
logging per client - done
Logging Correlation Ids - done
Number of clients behavior  - Should I make my queue to track the number of requests per host per all clients? or change the way I deal with clients - Done
Logging Behavior - Done
Exit app after command execution is completed - Done
Implement RunInParallel
Handle Response Payload As Bytes and read it as soon as it arrives
download embedded resources
Resource Usage Tracker
Command to configure file logging options
Command to configure watchdog
Command to configure httpclient
support for http2


